cube <- function(x, n) {
x^3
}
cube(3)
x <- 1:10
if(x > 5) {
x <- 0
}
x
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
a <- available.packages()
a
View(a)
View(a)
a[100]
a[400]
a[4000]
a[3000]
a[2000]
a[3500]
a[2500]
a[2200]
a[2400]
a[2450]
install.packages("KernSmooth")
library(KernSmooth)
library(datasets)
data(iris)
?iris
iris
iris[,1]
mean(iris[,1])
?rowmeans
rowMeans
apply(iris, 2, mean)
apply(iris[, 1:4], 2, mean)
apply(iris[, 1:4], 1, mean)
rowMeans(iris[, 1:4])
data(mtcars)
mtcars
?mtcars
mean(mtcars$mpg, mtcars$cyl)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
apply(mtcars, 2, mean)
lapply(mtcars, mean)
sapply(split(mtcars$hp, mtcars$cyl), mean)
temp = sapply(split(mtcars$hp, mtcars$cyl), mean)
temp
temp[3]
temp[3]-temp[1]
debug(ls)
ls
debug(ls)
ls()
iris
mean(iris[,1])
sapply(mtcars, cyl, mean)
with(mtcars, tapply(mpg, cyl, mean))
sapply(split(mtcars$mpg, mtcars$cyl), mean)
?iris
?iris
?iris
library(datasets)
datasets(iris)
data(iris)
iris
iris
?iris
library(datsets)
library(datasets)
data(iris)
?iris
iris
sapply(split(iris$Sepal.Length, iris$Species), mean)
with(iris, tapply(Sepal.Length, Species, mean))
set.seed(1)
rpois(5, 2)
rpois(5, 2)
rpois(5, 2)
rpois(5, 2)
rpois(5, 2)
set.seed(!)
set.seed(1)
rpois(5, 2)
?qnorm
?rnorm
?set.seed
?dpois
set.seed(10)
x <- rbinom(10, 10, 0.5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
y
e
x
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
system.time()
?system.time
?pnorm
setwd("~/Documents/repos/num-methods/Root-finding/R")
source('secant.R')
source('secant.R')
result = biSection (f, 1, 2,50, 0.01)
source('secant.R')
result = secant (f, 1, 2,50, 0.01)
source('secant.R')
result = secant (f, 1, 2,50, 0.01)
source('secant.R')
result = secant (f, 1, 2,50, 0.01)
source('falsepos')
source('falsepos.R')
result = falsepos (f, 1, 2, 10, 0.01)
result
?inv
?inverse
x = c(1,2,3)
x
x[2:3]
X = c(1,2,3)
v_matrix = c((X[n] - X[n+1])^2, (X[n] - X[n+1]),1)
n=1
v_matrix = c((X[n] - X[n+1])^2, (X[n] - X[n+1]),1)
v_matrix
v_matrix = c((X[n] - X[n+1])^2, (X[n] - X[n+1]),1, 0, 0, 1, (X[n+2] - X[n+1])^2, (X[n+2] - X[n+1]),1)
v_matrix
temp = matrix(v_matrix, nrow=3, ncol=3)
temp
temp = matrix(v_matrix, nrow=3, byrow=True)
temp = matrix(v_matrix, nrow=3, byrow=TRUE)
temp
temp = c((X[n] - X[n+1])^2, (X[n] - X[n+1]),1, 0, 0, 1, (X[n+2] - X[n+1])^2, (X[n+2] - X[n+1]),1)
v_matrix = matrix(temp, nrow=3, byrow=TRUE)
v_matrix
X
X = c(-1,1,3)
temp = c((X[n] - X[n+1])^2, (X[n] - X[n+1]),1, 0, 0, 1, (X[n+2] - X[n+1])^2, (X[n+2] - X[n+1]),1)
v_matrix = matrix(temp, nrow=3, byrow=TRUE)
v_matrix
right_matrix = c(f(X[n]), f(X[n+1]), f(X[n+2]))
right_matrix
middle_matrix = (solve(v_matrix)) * right_matrix
middle_matrix
solve_v_matrix
solve(v_matrix)
?transpose
?t
t(right_matrix)
right_matrix
middle_matrix = (solve(v_matrix)) * t(right_matrix)
middle_matrix = (solve(v_matrix)) %*% t(right_matrix)
middle_matrix = (solve(v_matrix)) %*% right_matrix
middle_matrix
?sign
?sqrt
source('muller.R')
source('muller.R')
result = muller (f, -1, 1, 3, 10, 0.01)
source('muller.R')
result = muller (f, -1, 1, 3, 10, 0.01)
result
